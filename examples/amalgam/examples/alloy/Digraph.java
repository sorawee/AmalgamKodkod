package amalgam.examples.alloy;


import java.util.Arrays;
import java.util.List;

import kodkod.ast.Decls;
import kodkod.ast.Expression;
import kodkod.ast.Formula;
import kodkod.ast.Relation;
import kodkod.ast.Variable;
import kodkod.ast.operator.FormulaOperator;
import kodkod.engine.AmalgamCore;
import kodkod.engine.Solution;
import kodkod.engine.config.Options;
import kodkod.instance.Bounds;
import kodkod.instance.TupleFactory;
import kodkod.instance.TupleSet;
import kodkod.instance.Universe;

public class Digraph {

	public static void main(String[] args)
	{
		// autogenerated kodkod for digraph alloy spec
		Relation x0 = Relation.nary("Int/next", 2);
		Relation x1 = Relation.unary("seq/Int");
		Relation x2 = Relation.unary("String");
		Relation x3 = Relation.unary("this/Node");
		Relation x4 = Relation.nary("this/Node.edge", 2);
		List<String> atomlist = Arrays.asList(
		 "Node$0", "Node$1", "Node$2"
		);
		Universe universe = new Universe(atomlist);
		TupleFactory factory = universe.factory();
		Bounds bounds = new Bounds(universe);
		TupleSet x0_upper = factory.noneOf(2);
		bounds.boundExactly(x0, x0_upper);
		TupleSet x1_upper = factory.noneOf(1);
		bounds.boundExactly(x1, x1_upper);
		TupleSet x2_upper = factory.noneOf(1);
		bounds.boundExactly(x2, x2_upper);
		TupleSet x3_upper = factory.noneOf(1);
		x3_upper.add(factory.tuple("Node$0"));
		x3_upper.add(factory.tuple("Node$1"));
		x3_upper.add(factory.tuple("Node$2"));
		bounds.bound(x3, x3_upper);
		TupleSet x4_upper = factory.noneOf(2);
		x4_upper.add(factory.tuple("Node$0").product(factory.tuple("Node$0")));
		x4_upper.add(factory.tuple("Node$0").product(factory.tuple("Node$1")));
		x4_upper.add(factory.tuple("Node$0").product(factory.tuple("Node$2")));
		x4_upper.add(factory.tuple("Node$1").product(factory.tuple("Node$0")));
		x4_upper.add(factory.tuple("Node$1").product(factory.tuple("Node$1")));
		x4_upper.add(factory.tuple("Node$1").product(factory.tuple("Node$2")));
		x4_upper.add(factory.tuple("Node$2").product(factory.tuple("Node$0")));
		x4_upper.add(factory.tuple("Node$2").product(factory.tuple("Node$1")));
		x4_upper.add(factory.tuple("Node$2").product(factory.tuple("Node$2")));
		bounds.bound(x4, x4_upper);
		Variable x8=Variable.unary("show_this");
		Decls x7=x8.oneOf(x3);
		Expression x11=x8.join(x4);
		//Formula x10=x11.lone(); // !!! only one out edge allowed for each node
		Formula x10=x11.some();   // !!! now just enforce that every node has SOME out edge, possibly >1 
		Formula x12=x11.in(x3);
		Formula x9=x10.and(x12);
		Formula x6=x9.forAll(x7);
		Expression x14=x4.join(Expression.UNIV);
		Formula x13=x14.in(x3);
		Formula x16=x3.some();
		Formula x17=x0.eq(x0);
		Formula x18=x1.eq(x1);
		Formula x19=x2.eq(x2);
		Formula x20=x3.eq(x3);
		Formula x21=x4.eq(x4);
		Formula x5=Formula.compose(FormulaOperator.AND, x6, x13, x16, x17, x18, x19, x20, x21);

		// spin up amalgam
		Options options = new Options();
		options.setSymmetryBreaking(0);
		AmalgamCore amalgam = new AmalgamCore(options);
		// solve it
		Solution initialSolution = amalgam.solve(x5, bounds);		
		System.out.println("bounds=\n"+bounds);
		System.out.println("f=\n"+x5);
		System.out.println("initialSolution=\n"+initialSolution);		
		// go places
		System.out.println("maximize(initialSolution)=\n"+amalgam.maximize());
		System.out.println("minimize that=\n"+amalgam.minimize());
		System.out.println("augment with a node=\n"+amalgam.augment(x3,factory.tuple(universe.atom(2))));
		System.out.println("max that=\n"+amalgam.maximize());
		System.out.println("min that=\n"+amalgam.minimize());
	}
}
